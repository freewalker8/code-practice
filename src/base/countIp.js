/**
 * 描述
在本题中，我们需要处理地址信息，其由 
I
P
IP 地址和子网掩码组成，这两者均形如 
"*.*.*.*"
"*.*.*.*" ，由四段数字组成，每段数字之间以点分隔。

我们定义五类 
I
P
IP 地址：
∙
 
∙A类：
"1.0.0.0"-"126.255.255.255"
"1.0.0.0"-"126.255.255.255" ；
∙
 
∙B类：
"128.0.0.0"-"191.255.255.255"
"128.0.0.0"-"191.255.255.255" ；
∙
 
∙C类：
"192.0.0.0"-"223.255.255.255"
"192.0.0.0"-"223.255.255.255" ；
∙
 
∙D类：
"224.0.0.0"-"239.255.255.255"
"224.0.0.0"-"239.255.255.255" ；
∙
 
∙E类：
"240.0.0.0"-"255.255.255.255"
"240.0.0.0"-"255.255.255.255" 。

我们定义私有 
I
P
IP 地址：
∙
 
∙
"10.0.0.0"-"10.255.255.255"
"10.0.0.0"-"10.255.255.255" ；
∙
 
∙
"172.16.0.0"-"172.31.255.255"
"172.16.0.0"-"172.31.255.255" ；
∙
 
∙
"192.168.0.0"-"192.168.255.255"
"192.168.0.0"-"192.168.255.255" 。

我们定义合法的子网掩码：
∙
 
∙将 
I
P
IP 地址转换为二进制后，必须由若干个连续的 
1
1 后跟若干个连续的 
0
0 组成；
∙
 
∙例如，
"1.1.1.5"
"1.1.1.5" 是一个非法的子网掩码，因为它转换为二进制后为 
1.1.1.101
1.1.1.101 ，中间出现了 
0
0 后又出现了 
1
1 ；
∙
 
∙注意，全为 
1
1 或全为 
0
0 的子网掩码也是非法的。

现在，你需要分类统计ABCDE类地址的数量、错误 
IP
IP 或错误子网掩码的数量、私有 
IP
IP 的数量。

特别地，我们还有以下提示：
∙
 
∙类似于 
"0.*.*.*"
"0.*.*.*" 和 
"127.*.*.*"
"127.*.*.*" 的 
I
P
IP 地址不属于上述输入的任意一类，也不属于不合法 
I
P
IP 地址；
∙
 
∙一个 
I
P
IP 地址既可以是私有 
I
P
IP 地址，也可以是五类 
I
P
IP 地址之一，计数时请分别计入。

输入描述：
本题将会给出 
1
≦
T
≦
1000
1≦T≦1000 条地址信息，确切数字未知，您需要一直读入直到文件结尾；您也可以参考 牛客网在线判题系统使用帮助 获得更多的使用帮助。每条地址信息描述如下：

在一行上先输入一个字符串，代表 
I
P
IP 地址；随后，在同一行输入一个字符串，代表子网掩码；使用 
"
 
"
" " 分隔。
输出描述：
在一行上输出七个整数，分别代表ABCDE类地址的数量、错误 
IP
IP 或错误子网掩码的数量、私有 
IP
IP 的数量。
示例1
输入：
10.70.44.68~1.1.1.5
1.0.0.1~255.0.0.0
192.168.0.2~255.255.255.0
19..0.~255.255.255.0
复制
输出：
1 0 1 0 0 2 1
复制
说明：
对于第一条地址信息，
"10.70.44.68"
"10.70.44.68" 是其 
I
P
IP 地址，
"255.254.255.0"
"255.254.255.0" 是其子网掩码；该条地址的子网掩码非法。
对于第二条地址信息，
I
P
IP 地址和子网掩码均无误，且属于A类地址。
对于第三条地址信息，
I
P
IP 地址和子网掩码均无误，且属于C类地址，同时属于私有 
I
P
IP 地址。
对于第四条地址信息，
I
P
IP 地址非法。
*/

const countMap = {
  'A': 0,
  'B': 0,
  'C': 0,
  'D': 0,
  'E': 0,
  'private': 0,
  'err': 0
};

function countIpType(ip) {
  // A
  if (/^(12[0-6]|1[0-1]\d|[1-9]\d|[1-9])\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$/.test(ip)) {
      countMap.A += 1;
  } else if (/^(1[2-8]\d|19[0-1])\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.([0-9]|[0-9]\d\d?|2[0-5][0-5])$/.test(ip)) {
      countMap.B += 1;
  } else if (/^(19[2-9]|2[0-2][0-3])\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip)) {
      countMap.C += 1;
  } else if (/^(22[4-9]|23\d)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip)) {
      countMap.D += 1;
  } else if (/^(24\d|25[0-5])\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip)) {
      countMap.E += 1;
  } 
  // 私有地址
  if (
      /^10\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip) ||
      /^172\.(1[6-9]|2\d|3[01])\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip) ||
      /^192\.168\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip)
  ) {
      countMap.private += 1;
  } 
  // 不是IP格式
  if (!/^\d+\.\d+\.\d+\.\d+$/.test(ip)) {
      countMap.err +=1;
  }
}


function countYanma(ip) {    
   // 子网掩码
  const parts = ip.split('.');
  let binary = '';
  parts.forEach(part => {    
    binary += Number(part).toString(2);
});
  if (
      binary.length === binary.split('').filter(b => b === '1').length || // 全是1
      binary.length === binary.split('').filter(b => b === '0').length || // 全是0
      /101/.test(binary) // 最后一个1后面不全是0
  ) {
      countMap.err +=1;
  }
}

// test
const ipList = [
  '10.70.44.68~1.1.1.5',
  '1.0.0.1~255.0.0.0',
  '192.168.0.2~255.255.255.0',
  '19..0.~255.255.255.0'
];

ipList.forEach(ip => {
  const [ipStr, maskStr] = ip.split('~'); debugger;
  countIpType(ipStr);
  countYanma(maskStr);
});

console.log(`${countMap.A} ${countMap.B} ${countMap.C} ${countMap.D} ${countMap.E} ${countMap.err} ${countMap.private}`);
